# 그리디 알고리즘

- 문제 해결 중 현재에서 가장 좋은 선택을 하는 방법
- 최적의 해는 아님
- 탐욕법으로 얻은 해가 최적의 해가 되는 상황에서 이를 추론할 수 있어야 풀리도록 출제
- 큰 단위가 작은 단위의 배수가 아니라면 다른 알고리즘을 생각할 수 있어야 함
- 최소한의 아이디어를 떠올리고 정당한 방법인지 검토할 수 있어야 함

## 거스름돈 문제

## 1이 될 때까지

> n과 k가 주어졌을 때, n이 1이 되기까지 1을 빼거나 k로 나눌 수 있다. 연산 수가 최소가 되도록 코드를 작성하라.

- 방법 1: 반복문으로 n이 k로 나누어지는지 확인하여 가능하다면 나누고 그렇지 않다면 -1
- 방법 2: 
  - n을 k로 나눴을 때 몫을 구할 수 있다. 
  - 이 몫과 k를 곱하면 n으로부터 가장 가까운 k의 배수를 구할 수 있다. 
  - n에 k의 배수를 뺀 값은 방법 1에서의 뺄셈 반복 횟수가 된다.(반복 수가 줄어듦) 
  - k의 배수에 k를 나누고 이를 n에 대입하여 반복한다.
  - 마지막에 n이 k보다 작다면, 결과값에 n - 1 만큼을 더한다.

```py
n, k = map(int, input().split())

count = 0
while n != 1:
  gap = (n // k) * k
  count += (n - gap)
  n = gap

  if n < k:
    break
  
  count += 1
  n //= k

count += (n - 1)
print(count)
```

## 곱하기와 더하기

> 각 자리가 숫자로 이루어진 문자열 S가 주어졌을 때, 왼쪽부터 하나씩 모든 숫자를 확인하면 숫자 사이에 + 또는 x 를 넣어 만들 수 있는 가장 큰 수를 구하는 프로그램을 작성하라. 모든 연산은 왼쪽부터 수행된다.

- 값이 0이거나 1이면 곱하는 것보다 더하는게 더 값이 높다.
- 최초 0이 들어왔을 때를 대비하여 결과값이 2보다 작으면 더한다.
- 다음 값이 2보다 작으면 더한다.

```py
n = input()

result = int(n[0])
for i in range(1, len(n)):
  if result <= 1 or int(n[i]) <= 1:
    result += int(n[i])
  else:
    result *= int(n[i])

print(result)
```

## 모험가 길드

> 한 마을에 모험가가 N명 있다. 모험가 길드에는 N명의 모험가를 대상으로 '공포도'를 측정했는데, '공포도'가 높은 모험가는 위기 대처 능력이 떨어진다. 이에 공포도가 X인 모험가는 반드시 X명 이상으로 구성한 모험가 그룹에 참여해야 한다고 규정했다. 예를들어 공포도가 1인 모험가는 1명의 그룹이 가능하고, 공포도가 3인 모험가는 3명일 때 가능하다. 이 때, 최대 몇 개의 모험가 그룹을 만들 수 있는지 작성하라.

- 입력
  - 모험가의 수 N
  - 각 모험가의 공포도 리스트
- 정렬한다.
- 그룹으로 묶을 때 최소 인원을 채워서 보낸다. 최소 인원은 현재 공포도이다.

```py
# 모험가 길드

n = int(input())
array = list(map(int, input.split()))
array.sort()

result = 0
count = 0

for i in array:
  count += 1  # 모험가 추가
  if count >= i: # 모험가가 공포도보다 많으면
    result += 1 # 결성
    count = 0 # 다음 그룹으로

print(result)
```

# 구현

알고리즘을 소스코드로 바꾸는 과정

- 풀이는 쉽지만 소스코드로 옮기기 어려운 것
  - 코드가 길어지는 문제
  - 실수 연산을 다루고 특정 소수점까지 출력
  - **문자열을 특정 기준에 따라 끊어 처리**
  - 적절한 라이브러리를 찾아서 사용하는 문제
  - **순열, 조합** 문제
  - **2차원 공간 및 행렬** 문제
    - 2차원 리스트를 사용할 때, 이동하는 방향에 따라 어떻게 움직여야 할지 고민 필요

```py
# 동, 북, 서, 남
dx = [0, -1, 0, 1]
dy = [1, 0, -1 ,0]

# 현재 위치
x, y = 2, 2

for i in range(4):
  # 다음 위치
  nx = x + dx[i]
  ny = y + dy[i]
  print(nx, ny)
```

> N x N 크기의 정사각형 공간에 여행가가 있다. 가장 왼쪽 위 좌표는 (1, 1)이며, 가장 오른쪽은 (N, N)이다. 여행가는 상, 하, 좌, 우로 이동할 수 있다. 계획서에 따라 여행가는 움직이며, 지도 밖으로 나가는 움직임은 무시된다. 

- 먼저 동서남북을 정의한다. 
  - `dir=['동', '서', '남', '북']`
- 그에 따른 방향 벡터를 정의한다.
  - dx = [1, -1, 0, 0]
  - dy = [0, 0, 1, -1]
- 이동 계획서를 하나씩 읽으면서 dx, dy를 임시 변수에 저장하고, 맵 밖으로 벗어나면 처리하지 않도록 짠다.

```py
N = int(input())
plan = input().split()

# 상하좌우
dir = ['U', 'D', 'L', 'R']
dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]

x, y = 1, 1

for i in plan:
  direct = dir.index(i) # 해당 방향으로의 인덱스를 받아와서
  if 1 <= dx[direct] + x <= 100 and 1 <= dy[direct] + y <= 100: # 범위를 넘지 않으면
    x += dx[direct] # 좌표 이동
    y += dy[direct]

print(x, y)
```
## 시각

> 정수 N이 입력되면 00시 00분 00초부터 N시 59분 59초까지의 모든 시각 중에 3이 하나라도 포함되는 모든 경우의 수를 구하는 프로그램을 작성

- Brute force(완전탐색) 문제
- 하루는 86,400초이다. 1초에 n천만번 계산하는 컴퓨터에게 별거 아니다.
- 참고: 최대값 23을 넣었을 때도 185ms가 걸렸다.
- 시각을 1 증가시키면서 3이 하나라도 포함하는지 확인

```py
n = int(input())

result = 0

for i in range(n + 1):
  for j in range(60):
    for k in range(60):
      if '3' in str(i) + str(j) + str(k):
        result += 1

print(result)
```

## 왕실의 나이트

> 8 x 8 좌표 평면이 있다. 특정 한 칸에 "나이트"가 서있다. 나이트는 L자 형태로만 이동할 수 있으며 좌표 밖으로 나갈 수 없다. 나이트는 특정 위치에서 2가지 경우로 이동할 수 있다. 1) 수평으로 2칸 이동한 뒤에 수직으로 한 칸 이동 2) 수직으로 2칸 이동한 뒤에 수평으로 한 칸 이동. 나이트가 위치한 좌표를 나타내는 두 문자로 구성된 문자열이 입력될 때(예: A1), 나이트가 이동할 수 있는 경우의 수를 구하라.

```py
point = input() # e3 같은 포인트를 입력받음
boundary = 8    # 경계
x = point[0]    # x 좌표
dx= ['a','b','c','d','e','f','g','h']
x = dx.index(x) # x 좌표를 해당 인덱스로부터 얻음
y = int(point[1])


# print(x, y)

# 최대 8방향이 가능하므로, 가능한 범위 입력
conx = [1, 2, 2, 1, -1, -2, 2, 1]
cony = [2, 1, -1, -2, -2, -1, -1, -2]

# steps = [(-2, -1), (-1, -2), (1, -2), ... 등으로 바꿀 수도 있음]

result = 0

for i in range(boundary):
  if 0 < x + conx[i] < boundary+1 and 0 < y + cony[i] < boundary+1:
    result += 1

print(result)
```

## 문자열 재정렬

> 알파벳 대문자와 숫자로만 구성된 문자열이 입력으로 주어진다. 이 때 모든 알파벳을 오름차순으로 정렬하여 이어서 출력한 뒤에, 그 뒤에 모든 숫자를 더한 값을 이어서 출력. 

- 예를 들어 K1KA5CB7이 들어오면 ABCKK13을 출력

```py
# input을 받고
string = input()
# 문자일 경우 추가할 리스트를 만든다.
str_arr = list()
# 숫자 초기화
result = 0

for char in string:
  if char.isalpha():  # 알파벳이면
    str_arr.append(char)  # 추가
  else: # 숫자면
    result += int(char) # 결과값 추가

str_arr.sort()  # 정렬하고

if result != 0: # 만약 숫자가 하나라도 있으면
  str_arr.append(str(result)) # 문자열 배열 뒤에 추가

print(''.join(str_arr)) # 문자열 배열을 합쳐서 print
```